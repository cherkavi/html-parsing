package shop_list.html.parser.engine.multi_page.standart;

import org.w3c.dom.Element;
import org.w3c.dom.Node;

import shop_list.html.parser.engine.exception.EParseException;
import shop_list.html.parser.engine.exception.EParseExceptionItIsNotRecord;
import shop_list.html.parser.engine.exception.EParseExceptionNotInStore;
import shop_list.html.parser.engine.multi_page.section.url_next_section.Analisator;
import shop_list.html.parser.engine.multi_page.section.url_next_section.IAnalisatorAware;
import shop_list.html.parser.engine.record.Record;

public abstract class AnalisatorRecordListBaseMultiPage extends ListBaseMultiPage implements IAnalisatorAware{
	
	/** получить относительный (относительно Record) XPath путь к Наименованию, будет использован {@link Node#getTextContent()} */
	protected abstract String recordFromNodeInRecordToName();

	/** получить относительный (относительно Record) XPath путь к URL, будет получен с помощью метода получения аттрибута {@link Element#getAttribute(String)} из метода:*/
	protected abstract String recordFromNodeInRecordToUrl();

	/** получить относительный (относительно Record) XPath путь к Цене в гривне для получения методом {}
	 * @return null, если нет в наличии 
	 * */
	protected abstract String recordFromNodeInRecordToPrice();
	
	/**  получить текст который будет "приведен" к Float для Price 
	 * <br>
	 * если обработчик не требуется - просто вернуть само значение 
	 * */
	protected abstract String recordFromNodeInRecordToPriceBeforeConvert(String priceText);

	/** получить относительный (относительно Record) XPath путь к Цене в USD для получения методом {}
	 * @return null, если нет в наличии 
	 */
	protected abstract String recordFromNodeInRecordToPriceUsd();

	/**  получить текст который будет "приведен" к Float для PriceUsd 
	 * <br>
	 * если обработчик не требуется - просто вернуть само значение 
	 * */
	protected abstract String recordFromNodeInRecordToPriceUsdBeforeConvert(String priceText);

	/** получить относительный (относительно Record) XPath путь к Цене в HRN для получения методом {}
	 * @return null, если нет в наличии 
	 * */
	protected abstract String recordFromNodeInRecordToPriceEuro();

	/**  получить текст который будет "приведен" к Float для PriceEuro
	 * <br>
	 * если обработчик не требуется - просто вернуть само значение 
	 *  */
	protected abstract String recordFromNodeInRecordToPriceEuroBeforeConvert(String priceText);
	
	/** получить имя аттрибута для извлечения из элемента, на который указывается URL (default = "href") */
	protected String getAttributeForExtractRecordUrl(){
		return "href";
	}
	/** нужно ли удалять из полного пути к Record полное имя стартовой страницы ? */
	protected abstract boolean recordIsRemoveStartPageFromUrl();
	
	/** нужно ли проверять на наличие товара ( то есть есть ли ссылка на текст, который идентифицирует наличие товара ),
	 * возвращает XPath на элемент, который должен быть получен в виде текста  
	 * @return null - если проверка не требуется
	 * если проверка требуется - переопределите 
	 * */
	protected abstract String recordFromNodeIsPresent();
	
	/** текст, который должен быть в наличии в строке  на которую указывает {{@link #recordFromNodeIsPresent()}} 
	 * @return null - достаточно просто наличие элемента, на который указывает {@link #recordFromNodeIsPresent()}
	 * @return text - нужно чтобы в строке, на которую указывает {@link #recordFromNodeIsPresent()} ОБЯЗАТЕЛЬНО содержался данный текст (CaseSensetive) 
	 * */
	protected abstract String recordFromNodeIsPresentText();
	
	private Analisator analisator=null;
	
	/** получить в виде массива из трех строк полные ссылки на одну секцию ( один раздел ) для парсинга
	 * <ul>
	 * 	<li><b>0</b> - первая страница раздела </li>
	 * 	<li><b>1</b> - вторая страница раздела </li>
	 * 	<li><b>2</b> - третья страница раздела </li>
	 * </ul>
	 *   */
	protected abstract String[] getThreePageForAnalisator(); 
	
	/** */
	public Analisator getAnalisator(){
		if(analisator==null){
			String[] pages=getThreePageForAnalisator();
			try{
				this.analisator=new Analisator(pages[0], pages[1], pages[2]);
			}catch(Exception ex){
				logger.error(this, "#getAnalisator Exception: "+ex.getMessage());
			}
		}
		return this.analisator;
	}
	
	/** подготовить URL перед предоставлением конечному объекту */
	protected String prepareUrlBeforeSave(String url){
		return url;
	}
	
	/** Проверка записи на существование, если задан путь к проверяющему Node {@link #recordFromNodeIsPresent},
	 *  а так же задан текст, который должен быть в этом Node {@link #recordFromNodeIsPresentText()},
	 *  <br>
	 *  <ul>
	 *  	<li><b>true</b> - текст должен <b>присутствовать</b> (хотя бы частично, иначе запись считается "не на складе" </li>
	 *  	<li><b>false</b> - текст должен <b>отсутствовать</b> (хотя бы частично, иначе запись считается "не на складе" )</li>
	 *  </ul>
	 *  <br>
	 *  не учитывается, в случае если {@link #recordFromNodeIsPresentText()} возвращает null
	 */
	protected boolean isPresentTextExistsMustPresent(){
		return true;
	}
	
	protected Record getRecordFromNode(Node node) throws EParseException{
		try{
			// element exists
			if(recordFromNodeIsPresent()!=null){
				// проверка на наличие записи 
				Node presentNode=this.parser.getNodeFromNode(node, this.recordFromNodeIsPresent());
				if(presentNode==null){
					logger.debug(this, "Не найден обязательный NODE ");
					throw new EParseExceptionItIsNotRecord();
				}
				// проверка на наличие необходимого текста, если таковой необходим
				if(recordFromNodeIsPresentText()!=null){
					// проверить на наличие текста в строке, если текста нет - вернуть null
					if(isPresentTextExistsMustPresent()){
						// текст должен существовать
						if(presentNode.getTextContent().indexOf(this.recordFromNodeIsPresentText())<0){
							// текст не найден - запись "не на складе"
							logger.debug(this, "обязательный NODE найден, текст не соответствует: "+presentNode.getTextContent());
							throw new EParseExceptionItIsNotRecord();
						}
					}else{
						// текст не должен существовать
						if(presentNode.getTextContent().indexOf(this.recordFromNodeIsPresentText())>=0){
							// текст найден - запись "не на складе"
							logger.debug(this, "обязательный NODE найден, текст соответствует (not) - запись не на складе: "+presentNode.getTextContent());
							throw new EParseExceptionItIsNotRecord();
						}
					}
				}
			}

			// name
			Node elementName=this.parser.getNodeFromNode(node, recordFromNodeInRecordToName());
			if(elementName==null){
				logger.info(this, "name element does not found:"+recordFromNodeInRecordToName());
				throw new EParseExceptionItIsNotRecord();
			}
			String name=elementName.getTextContent().trim();
			// url
			Element elementUrl=(Element)this.parser.getNodeFromNode(node, recordFromNodeInRecordToUrl());
			if(elementUrl==null){
				logger.info(this, "url element does not found:"+recordFromNodeInRecordToUrl());
				throw new EParseExceptionItIsNotRecord();
			}
			String url=null;
			if(this.recordIsRemoveStartPageFromUrl()){
				url=this.removeStartPage(prepareUrlBeforeSave(elementUrl.getAttribute(this.getAttributeForExtractRecordUrl())));
			}else{
				url=prepareUrlBeforeSave(elementUrl.getAttribute(this.getAttributeForExtractRecordUrl()));
			}
			// price
			// priceUsd
			// priceEuro
			Float price=null;
			Float priceUsd=null;
			Float priceEuro=null;
			if(this.recordFromNodeInRecordToPrice()!=null){
				// есть путь к price
				Node element=getPriceNodeFromLeafNode(node);
				if(element!=null){
					price=getFloatFromString(this.recordFromNodeInRecordToPriceBeforeConvert(recordFromNodeInRecordToPriceGetTextFromElement(element)));
				}else{
					logger.info(this, "цена в ГРН указана, элемент не найден ");
				}
			}
			if(this.recordFromNodeInRecordToPriceUsd()!=null){
				// есть путь к price
				Node element=getPriceUsdNodeFromLeafNode(node);
				if(element!=null){
					// элемент найден 
					priceUsd=getFloatFromString(this.recordFromNodeInRecordToPriceUsdBeforeConvert(recordFromNodeInRecordToPriceUsdGetTextFromElement(element)));
				}else{
					logger.info(this, "цена в USD указана, элемент не найден ");
				}
			}
			if(this.recordFromNodeInRecordToPriceEuro()!=null){
				// есть путь к price
				Node element=getPriceEuroNodeFromLeafNode(node);
				if(element!=null){
					// элемент найден 
					priceEuro=getFloatFromString(this.recordFromNodeInRecordToPriceEuroBeforeConvert(recordFromNodeInRecordToPriceEuroGetTextFromElement(element)));
				}else{
					logger.info(this, "цена в USD указана, элемент не найден ");
				}
			}
			// проверка на наличие какой-либо цены  
			if(isFloatEmpty(price)&&isFloatEmpty(priceUsd)&&isFloatEmpty(priceEuro)){
				this.logger.debug(this, "нет цены в записи");
				throw new EParseExceptionNotInStore();
			}
			return new Record(name, null, url, price, priceUsd, priceEuro);
		}catch(NullPointerException npe){
			this.logger.debug(this, "AnalisatorRecordListBaseMultiPage данная запись не есть Record");
			throw new EParseExceptionItIsNotRecord();
		}
	};
	
	/** получить цену из элемента, который содержит все данные о текущей позиции в целом   */
	protected Node getPriceNodeFromLeafNode(Node node){
		return this.parser.getNodeFromNode(node, this.recordFromNodeInRecordToPrice());		
	}
	
	/** получить цену USD из элемента, который содержит все данные о текущей позиции в целом   */
	protected Node getPriceUsdNodeFromLeafNode(Node node){
		return this.parser.getNodeFromNode(node, this.recordFromNodeInRecordToPriceUsd());
	}

	/** получить цену EURO из элемента, который содержит все данные о текущей позиции в целом   */
	protected Node getPriceEuroNodeFromLeafNode(Node node){
		return this.parser.getNodeFromNode(node, this.recordFromNodeInRecordToPriceEuro());
	}
	
	/** получить на основании элемента текст, из которого будет получена цена ГРН ( в случае, когда цена "хранится" в аттрибуте элемента) */
	protected String recordFromNodeInRecordToPriceGetTextFromElement(Node element) {
		return element.getTextContent();
	}

	/** получить на основании элемента текст, из которого будет получена цена USD ( в случае, когда цена "хранится" в аттрибуте элемента) */
	protected String recordFromNodeInRecordToPriceUsdGetTextFromElement(Node element) {
		return element.getTextContent();
	}

	/** получить на основании элемента текст, из которого будет получена цена EURO ( в случае, когда цена "хранится" в аттрибуте элемента) */
	protected String recordFromNodeInRecordToPriceEuroGetTextFromElement(Node element) {
		return element.getTextContent();
	}

	/** является ли Float значение null или 0 */
	private boolean isFloatEmpty(Float value){
		if(value==null)return true;
		if(value.floatValue()==0)return true;
		return false;
	}
}
